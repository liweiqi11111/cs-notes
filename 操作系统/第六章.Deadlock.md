# 死锁



## 资源

大部分死锁都和资源有关

每一种资源类型可以有多个实例

分类1：

- **Reusable Resources**

  Acquire请求->Use使用->Release释放

  例：CPU、内存、磁盘空间、I/O设备、文件、数据库、信号量

- Consumable Resources

  Create->Acquire->Use，使用完就不存在了
  
  例：messages、buffers of information、interrupts

分类2：

- 可抢占资源

  ​	例：CPU、内存... 不会产生死锁

- 不可抢占资源

  ​	例：Tape Drives, CD Recorder

分类3：

- 可被共享资源

  ​	例：只读文件

- 不可共享资源

  ​	例：Printers





## Deadlocks

### 发生资源死锁的条件

四个充分且必要条件

1. 互斥条件
2. 占有和等待条件
3. 不可抢占条件
4. 环路等待条件



### 死锁建模

有向图

**两类节点：进程(圆形表示)，资源(方形表示)**

**有向边：占有/请求一个资源**



结论：

图中没有cycle——>>没有死锁

图中有cycle——>>当每种资源类型**只有一个资源**时，会发生死锁



## 处理死锁

### 鸵鸟算法

死锁发生频率低、后果不严重——重启系统



### 死锁检测和死锁恢复

周期性地运行死锁检测算法

- 每种类型一个资源的死锁检测

  资源分配图中找cycle：依次将**每一个节点**作为一颗树的根节点，并**进行dfs**

- 每种类型多个资源的死锁检测

  n个进程，m种资源类型

  E：现有资源向量
  $$
  (E_1,E_2,E_3,...,E_m)
  $$


  A：可用资源向量
$$
  (A_1,A_2,A_3,...,A_m)
$$

  C：当前的分配矩阵
$$
  \begin{bmatrix}C_{11}&C_{12}&...&C_{1m}\\C_{21}&C_{22}&...&C_{2m}\\.&.&&.\\.&.&&.\\C_{n1}&C_{n2}&...&C_{nm}\end{bmatrix}
$$
  R：请求矩阵
$$
  \begin{bmatrix}R_{11}&R_{12}&...&R_{1m}\\R_{21}&R_{22}&...&R_{2m}\\.&.&&.\\.&.&&.\\R_{n1}&R_{n2}&...&R_{nm}\end{bmatrix}
$$
  有一个恒等式：$$\sum_{i=1}^{n}{C_{ij}} + A_j = E_j$$

  检测算法：

  1. 寻找一个没有标记的进程P~i~，对于它而言R矩阵的第i行向量小于或等于A。
  2. 如果找到了这样一个进程，那么将C矩阵的第i行向量加到A中，标记该进程，并转到第一步。
  3. 如果没有这样的进程，那么算法终止。

  **算法结束时，所有没有标记过的进程（如果存在的话）都是死锁进程。**

  

- 从死锁中恢复

  1. 利用抢占恢复

     是否可行还得看资源本身的特性

  2. 利用回滚恢复

     定期检查点检查(checkpointed)：将进程的状态写入一个文件以备以后重启

  3. 通过杀死进程恢复
  
     暴力但简单的方法



### 死锁避免

如果为了满足这一次请求的分配资源是安全的，则分配

- 资源轨迹图

  形象的看出每次资源分配是否安全

- **安全状态和不安全状态**

  从安全状态出发，系统能够保证所有进程都能完成；而从不安全状态出发，无法保证。

- 单个资源的银行家算法

  客户——进程

  贷款——资源

  银行家——操作系统

- 多个资源的银行家算法

  和死锁检测运行类似，但运行的动机不一样
  
  死锁检测的算法运行是为了检测当前系统是否已经进入**死锁状态**了
  
  而银行家算法运行是为了避免系统进入死锁状态





### 死锁预防

破坏死锁发生的条件

1. 破坏互斥条件

   I/O设备驱动程序中介绍的[假脱机技术 - 简书 (jianshu.com)](https://www.jianshu.com/p/495b837b746f)。

   避免分配那些不是绝对必需的资源，尽量做到尽可能少的进程可以真正请求资源。

2. 破坏占有并等待条件

   - 方法1：进程运行之前请求所有需要的资源

     ​	问题：无法在开始前知道进程所需的资源

     ​				资源利用率不高

   - 方法2：当一个进程请求资源时，先暂时释放其当前占用的所有资源，然后再尝试一次获得所需的全部资源

   - 方法3：当进程获得资源后设置一个计时器

3. 破坏不可抢占条件

   抢占资源，虚拟化和方法1类似

4. 破坏环路等待条件

   方法1：保证每个进程在任何时候都只能用一个资源
   
   方法2：对资源编号，只能按序请求资源





## 其他问题

- 两阶段加锁

  数据库系统

  和一次性申请所有资源类似

  

- 通信死锁

  区别资源死锁

  一系列进程中，每个进程因为等待另外一个进程引发的事件而产生阻塞

  解决：超时重传

  

- 活锁

  进程活动，没有阻塞但没有继续往下执行
  
  就是忙等待条件下发生的饥饿（starvation）
